#include <cctype>
#include <exception>
#include <fmt/format.h>
#include <iostream>
#include <fstream>
#include <ostream>
#include <string.h>
#include <algorithm>
#include <cstdint>
#include <string>
#include <sys/types.h>
#define VERSION 0.5

#define NUMLEGALMOD 68
const std::string LEGALMOD[68] = {"lshift", "lctrl", "lalt", "lgui", "rshift", "rctrl", "ralt", "rgui",
    "uparrow", "downarrow", "larrow", "rarrow", "backspace", "tab", "enter", "menu", "esc",
    "insert", "del", "pgup", "pgdown", "home", "end", "caps", "printscr", "sclock", 
    "pause", "numlock", "numslash", "numasterisk", "numminus", "numplus", "numenter",
    "num0", "num1", "num2", "num3", "num4", "num5", "num6", "num7", "num8", 
    "num9", "numdot", "kf1", "kf2", "kf3", "kf4", "kf5", "kf6", "kf7",
    "kf8", "kf9", "kf10", "kf11", "kf12", "kf13", "kf14", "kf15", "kf16", 
    "kf17", "kf18", "kf19", "kf20", "kf21", "kf22", "kf23", "kf24"
};

const std::string SPECIAL[68] = {"KEY_LEFT_SHIFT", "KEY_LEFT_CTRL", "KEY_LEFT_ALT", "KEY_LEFT_GUI",
    "KEY_RIGHT_SHIFT", "KEY_RIGHT_CTRL", "KEY_RIGHT_ALT", "KEY_RIGHT_GUI", "KEY_UP_ARROW",
    "KEY_DOWN_ARROW", "KEY_LEFT_ARROW", "KEY_RIGHT_ARROW", "KEY_BACKSPACE", "KEY_TAB",
    "KEY_RETURN", "KEY_MENU", "KEY_ESC", "KEY_INSERT", "KEY_DELETE", "KEY_PAGE_UP",
    "KEY_PAGE_DOWN", "KEY_HOME", "KEY_END", "KEY_CAPS_LOCK", "KEY_PRINT_SCREEN",
    "KEY_SCROLL_LOCK", "KEY_PAUSE", "KEY_NUM_LOCK", "KEY_KP_SLASH", "KEY_KP_ASTERISK",
    "KEY_KP_MINUS", "KEY_KP_PLUS", "KEY_KP_ENTER", "KEY_KP_0", "KEY_KP_1", "KEY_KP_2", 
    "KEY_KP_3", "KEY_KP_4", "KEY_KP_5", "KEY_KP_6", "KEY_KP_7", "KEY_KP_8", 
    "KEY_KP_9", "KEY_KP_DOT", "KEY_F1", "KEY_F2", "KEY_F3", "KEY_F4", 
    "KEY_F5", "KEY_F6", "KEY_F7", "KEY_F8", "KEY_F9", "KEY_F10", 
    "KEY_F11", "KEY_F12", "KEY_F13", "KEY_F14", "KEY_F15", "KEY_F16", 
    "KEY_F17", "KEY_F18", "KEY_F19", "KEY_F20", "KEY_F21", "KEY_F22", 
    "KEY_F23", "KEY_F24"  
};

bool includeBindingsHeader = true;
bool verbose = false;
uint8_t assignmentIndex = 0;
uint8_t assignmentCount = 0;
int debounceTime = 30;
int holdThreshold = 500;
int initBank = 0;
int initOS = 0;
int backlightIntensity = 70;

std::string linesLinux[16];
std::string linesWindows[16];
std::string linesMac[16];

std::string finalBank = "";
std::string PATH = "";

std::string getHex(uint8_t value){
    switch(value){
        case 0: return "0"; break;
        case 1: return "1"; break;
        case 2: return "2"; break;
        case 3: return "3"; break;
        case 4: return "4"; break;
        case 5: return "5"; break;
        case 6: return "6"; break;
        case 7: return "7"; break;
        case 8: return "8"; break;
        case 9: return "9"; break;
        case 10: return "A"; break;
        case 11: return "B"; break;
        case 12: return "C"; break;
        case 13: return "D"; break;
        case 14: return "E"; break;
        case 15: return "F"; break;
    }
    return "";
}

void printHelp(){
    std::cout << "Config generator tool for the freeMacro project: outputs config.h" << std::endl;
    std::cout << "Version: v" << VERSION << std::endl;
    std::cout << "Usage: ./genConfig [OPTION]" << std::endl;
    std::cout << std::endl;
    std::cout << "Optional arguments:" << std::endl;
    std::cout << "-v\t--verbose\tdisplay parsing details" << std::endl;
    std::cout << "-h\t--help\t\tdisplay this help and exit" << std::endl;
}

void generateBankConfig(std::string bank){
    std::ofstream output;
    output.open(PATH + "config.h", std::ios::app);
    if(includeBindingsHeader){
        output << "#include \"Keyboard.h\"\n";
        output << "#define BACKLIGHT_INTENSITY " << backlightIntensity << "\n";
        output << "#define HOLD_THRESHOLD " << holdThreshold << "\n";
        output << "#define DEBOUNCE_TIME " << debounceTime << "\n\n";
        output << "// Initial bank:\n";
        output << "uint8_t currentBank = " << initBank << ";\n\n";
        output << "/* Initial operating system\n  0: Linux\n  1: Windows\n  2: macOS\n*/\n\n";
        output << "uint8_t currentOS = " << initOS << ";\n\n";
        output << "\n/* Header generated by freeMacro genConfig v" << VERSION << "\n";
        output << "   To generate a new config, \"modify banks.layout\" and run genConfig,\n";
        output << "   then place the output (\"config.h\") in the \"freeMacro-firmware directory\" */\n";
        includeBindingsHeader = false;
    }
    output << "\n" << bank << "\n";
    output << "\tswitch(OS){\n";
    output << "\t\tcase 0:\n";
    output << "\t\tswitch(keyPressed){\n";
    for(int i = 0; i < 16; i++){
        output << "\t\t\t" << linesLinux[i] << "\n";
    }
    output << "\t\t} break;\n";
    output << "\t\tcase 1:\n";
    output << "\t\tswitch(keyPressed){\n";
    for(int i = 0; i < 16; i++){
        output << "\t\t\t" << linesWindows[i] << "\n";
    }
    output << "\t\t} break;\n";
    output << "\t\tcase 2:\n";
    output << "\t\tswitch(keyPressed){\n";
    for(int i = 0; i < 16; i++){
        output << "\t\t\t" << linesMac[i] << "\n";
    }
    output << "\t\t} break;\n";
    output << "\t}\n";
    output << "}\n";
    output.close();
}

int checkMod(std::string modifiers[31], int modN){
    int syntaxErrorIndex = -1;
    for(int i = 0; i < modN; i++){
        for(int j = 0; j < NUMLEGALMOD; j++){
            if(modifiers[i].compare(LEGALMOD[j])){
                if(modifiers[i].length() == 1) syntaxErrorIndex = -1;
                else syntaxErrorIndex = j;
            }
            else{
                syntaxErrorIndex = -1;
                break;
            }
        }
        if(syntaxErrorIndex != -1){
            std::cout << "genConfig: [ FAILED ] Syntax error for key \"" << modifiers[i] << "\" at index " << i << std::endl;
            return syntaxErrorIndex;
        }
    }
    for(int i = 0; i < modN; i++){
        if(modifiers[i].length() == 1) modifiers[i] = "\'" + modifiers[i] + "\'";
        else{
            for(int j = 0; j < NUMLEGALMOD; j++){
                if(modifiers[i] == LEGALMOD[j]) modifiers[i] = SPECIAL[j];
            }
        }
    }
    return -1; // success
}

std::string parseKeyCombo(std::string temp){
    std::transform(temp.begin(), temp.end(), temp.begin(), [](unsigned char c){return std::tolower(c);});
    std::string output = "";
    int separatorCount = 0;
    int separatorIndex[30];
    for(int i = 0; i < 30; i++) separatorIndex[i] = -1;
    for(int i = 0; i < temp.length(); i++){
        if(temp[i] == '+'){
            separatorIndex[separatorCount] = i;
            separatorCount++;
        }
    }
    if(separatorCount == 0) return "ERROR";
    std::string modifiers[31];  // meaningful length: separatorCount + 1
    for(int i = 0; i < 31; i++) modifiers[i] = "";
    for(int i = 0; i < separatorCount; i++){
        if(i == 0) modifiers[i] = temp.substr(0, separatorIndex[i]);
        else modifiers[i] = temp.substr(separatorIndex[i - 1] + 1, separatorIndex[i] - separatorIndex[i - 1] - 1);
    }
    if(temp.length() - 1 > separatorIndex[separatorCount - 1]) modifiers[separatorCount] = temp.substr(separatorIndex[separatorCount - 1] + 1, temp.length() - separatorIndex[separatorCount - 1] - 1);
    if(verbose){
        std::cout << "genConfig: Found separator indexes: ";
        for(int i = 0; i < separatorCount; i++) std::cout << separatorIndex[i] << " ";
        std::cout << std::endl << "genConfig: Found separator count: "<< separatorCount << std::endl;
        std::cout << "genConfig: Found keys in combo: ";
        for(int i = 0; i < separatorCount + 1; i++) std::cout << modifiers[i] << " ";
        std::cout << std::endl;
    }
    int checkError = checkMod(modifiers, separatorCount + 1);
    if(checkError != -1){
        std::cout << "genConfig: [ FAILED ] Illegal declaration in banks.layout" << std::endl;
        return "ERROR";
    }
    output = "case 0x0" + getHex(assignmentIndex) + ":";
    for(int i = 0; i < separatorCount + 1; i++){
        output +=  " Keyboard.press(" + modifiers[i] + "); delay(2);";
    }
    output += " Keyboard.releaseAll(); break;";
    return output;
}

int checkUnicode(std::string temp){
    if(temp.length() != 4){
        std::cout << "genConfig: [ FAILED ] Unicode values must be addressed by four digits in HEX (0 - F), " << temp << " contains " << temp.length() << std::endl;
        return 1;
    }
    const char HEX[16] = {'0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
    bool tempOK = true;
    for(int i = 0; i < temp.length(); i++){
        for(int j = 0; j < 16; j++){
            if(temp[i] != HEX[j]) tempOK = false;
            else{
                tempOK = true;
                break;
            }
        }
        if(tempOK == false){
            std::cout << "genConfig: [ FAILED ] \"" << temp << "\" is out of bounds for a Unicode character value" << std::endl;
            return 1;
        }
    }
    return 0;
}

int parseLineConfig(std::string line, std::string tokenHeader){
    std::string temp = line.substr(line.find('=') + 1, line.length() - line.find('=')); 
    if(verbose) std::cout << temp << std::endl;
    if(tokenHeader == "key"){
        bool isModifier = false;
        for(int i = 0; i < NUMLEGALMOD; i++){
            std::string Key = temp;
            std::transform(Key.begin(), Key.end(), Key.begin(), [](unsigned char c){return std::tolower(c);});
            if(0 == Key.compare(LEGALMOD[i])){
                temp = SPECIAL[i];
                isModifier = true;
                break;
            }
        }
        if(!isModifier){
            linesLinux[assignmentIndex] = "case 0x0" + getHex(assignmentIndex) + ": Keyboard.press('" + temp + "'); delay(10); Keyboard.releaseAll(); break;";
            linesWindows[assignmentIndex] = "case 0x0" + getHex(assignmentIndex) + ": Keyboard.press('" + temp + "'); delay(10); Keyboard.releaseAll(); break;";
            linesMac[assignmentIndex] = "case 0x0" + getHex(assignmentIndex) + ": Keyboard.press('" + temp + "'); delay(10); Keyboard.releaseAll(); break;";
        } else {
            linesLinux[assignmentIndex] = "case 0x0" + getHex(assignmentIndex) + ": Keyboard.press(" + temp + "); delay(10); Keyboard.releaseAll(); break;";
            linesWindows[assignmentIndex] = "case 0x0" + getHex(assignmentIndex) + ": Keyboard.press(" + temp + "); delay(10); Keyboard.releaseAll(); break;";
            linesMac[assignmentIndex] = "case 0x0" + getHex(assignmentIndex) + ": Keyboard.press(" + temp + "); delay(10); Keyboard.releaseAll(); break;";
            isModifier = false;
        }
    } 
    else if(tokenHeader == "str"){
        if(temp.length() < 1){
            std::cout << "genConfig: [ FAILED ] No string assignment found for case 0x0" << getHex(assignmentIndex) << std::endl;
            return 1;
        }
        linesLinux[assignmentIndex] = "case 0x0" + getHex(assignmentIndex) + ": Keyboard.print(\"" + temp + "\"); break;";
        linesWindows[assignmentIndex] = linesLinux[assignmentIndex];
        linesMac[assignmentIndex] = linesLinux[assignmentIndex];
    }
    else if(tokenHeader == "uni"){
        int checkUnicodeRet = checkUnicode(temp);
        if(checkUnicodeRet != 0) return 1;
        linesLinux[assignmentIndex] = "case 0x0" + getHex(assignmentIndex) +": Keyboard.press(KEY_LEFT_CTRL); delay(2); Keyboard.press(KEY_LEFT_SHIFT); delay(2); Keyboard.press('u'); delay(2); Keyboard.release('u'); delay(5); Keyboard.print(\"" + temp + "\"); delay(5); Keyboard.releaseAll(); break;";
        linesWindows[assignmentIndex] = "case 0x0" + getHex(assignmentIndex) + ": Keyboard.print(\"" + temp + "\"); delay(5); Keyboard.press(KEY_LEFT_ALT); delay(2); Keyboard.press('x'); delay(2); Keyboard.releaseAll(); break;";
        linesMac[assignmentIndex] = "case 0x0" + getHex(assignmentIndex) + ": Keyboard.press(KEY_LEFT_ALT); delay(20); Keyboard.print(\"" + temp + "\"); delay(5); Keyboard.releaseAll(); break;";
    } else if(tokenHeader == "com"){
        std::string combo = "";
        combo = parseKeyCombo(temp);
        if(combo == "ERROR") return 1;
        linesLinux[assignmentIndex] = combo;
        linesWindows[assignmentIndex] = combo;
        linesMac[assignmentIndex] = combo;
    }
    assignmentCount++;
    return 0;
}


void clearStringArray(){
    for(int i = 0; i < 16; i++){
        linesLinux[i] = "";
        linesWindows[i] = "";
        linesMac[i] = "";
    }
}

int checkVar(uint8_t var, std::string line){
    std::string arg = "";
    std::string userArg = "";
    std::string param = "";
    param = line.substr(line.find('=') + 1, line.length() - 5);
    arg = line.substr(0, line.find('='));
    userArg = line.substr(0, line.find('='));
    if(param.length() < 1){
        std::cout << "genConfig: [ FAILED ] No parameter found for modifier: ";
        switch(var){
            case 0: std::cout << "\"$OS_INIT\"" << std::endl; break;
            case 1: std::cout << "\"$BANK_INIT\"" << std::endl; break;
            case 2: std::cout << "\"$DEBOUNCE_TIME\"" << std::endl; break;
            case 3: std::cout << "\"$HOLD_TIME\"" << std::endl; break; 
        }
        return 1;
    }
    if(var == 0){
        std::string userInput = param;
        std::transform(param.begin(), param.end(), param.begin(), [](unsigned char c){return std::tolower(c);});
        std::transform(arg.begin(), arg.end(), arg.begin(), [](unsigned char c){return std::tolower(c);});
        if(arg.compare("$os_init")){
            std::cout << "genConfig: [ FAILED ] Invalid modifier keyword: \"" << userArg << "\"" << std::endl;
            return 1;
        }
        if(verbose) std::cout << "genConfig: Found init OS config parameter: " << userInput << std::endl;
        if(!param.compare("linux")) initOS = 0;
        else if(!param.compare("windows")) initOS = 1;
        else if(!param.compare("macos")) initOS = 2;
        else{
            std::cout << "genConfig: [ FAILED ] \"" << userInput << "\" is not a valid operating system designator" << std::endl;
            return 1;
        }
    } else if (var == 1){
        std::string userInput = param;
        std::transform(param.begin(), param.end(), param.begin(), [](unsigned char c){return std::tolower(c);});
        std::transform(arg.begin(), arg.end(), arg.begin(), [](unsigned char c){return std::tolower(c);});
        if(arg.compare("$bank_init")){
            std::cout << "genConfig: [ FAILED ] Invalid modifier keyword: \"" << userArg << "\"" << std::endl;
            return 1;
        }
        if(verbose) std::cout << "genConfig: Found init bank config parameter: " << param << std::endl;
        if(param.length() > 1){
            std::cout << "genConfig: [ FAILED ] Invalid parameter length for initial bank assignment: " << "expected length: 1, given: " << param.length() << std::endl;
            return 1;
        }
        if(param == "0") initBank = 0x00;
        else if(param == "1") initBank = 0x01;
        else if(param == "2") initBank = 0x02;
        else if(param == "3") initBank = 0x03;
        else if(param == "4") initBank = 0x04;
        else if(param == "5") initBank = 0x05;
        else if(param == "6") initBank = 0x06;
        else if(param == "7") initBank = 0x07;
        else if(param == "8") initBank = 0x08;
        else if(param == "9") initBank = 0x09;
        else if(param == "a") initBank = 0x0A;
        else if(param == "b") initBank = 0x0B;
        else if(param == "c") initBank = 0x0C;
        else {
            std::cout << "genConfig: [ FAILED ] Invalid bank parameter: " << userInput << "; expected: hex value 0 through C" << std::endl;
            return 1;
        }
    } else if (var == 2){
        std::transform(arg.begin(), arg.end(), arg.begin(), [](unsigned char c){return std::tolower(c);});
        if(arg.compare("$debounce_time")){
            std::cout << "genConfig: [ FAILED ] Invalid modifier keyword: \"" << userArg << "\"" << std::endl;
            return 1;
        }
        if(verbose) std::cout << "genConfig: Found debounce time config parameter: " << param << std::endl;
        if(param[0] == '0') {
            std::cout << "genConfig: [ FAILED ] Debounce time cannot cast to int: integer can't start with zero: \'" << param << "\'" << std::endl;
            return 1;
        }
        for(int i = 0; i < param.length(); i++){
            if(!isdigit(param[i])){
                std::cout << "genConfig: [ FAILED ] Debounce time cannot cast to int -> found string: \'" << param << "\'" << std::endl;
                return 1;
            }
        }
        debounceTime = std::stoi(param);
    } else if (var == 3){
        std::transform(arg.begin(), arg.end(), arg.begin(), [](unsigned char c){return std::tolower(c);});
        if(arg.compare("$hold_time")){
            std::cout << "genConfig: [ FAILED ] Invalid modifier keyword: \"" << userArg << "\"" << std::endl;
            return 1;
        }
        if(verbose) std::cout << "genConfig: Found hold time config parameter: " << param << std::endl;
        if(param[0] == '0') {
            std::cout << "genConfig: [ FAILED ] Hold time cannot cast to int: integer can't start with zero: \'" << param << "\'" << std::endl;
            return 1;
        }
        for(int i = 0; i < param.length(); i++){
            if(!isdigit(param[i])){
                std::cout << "genConfig: [ FAILED ] Hold time cannot cast to int -> found string: \'" << param << "\'" << std::endl;
                return 1;
            }
        }
        holdThreshold = std::stoi(param);
    } else if(var == 4){
        std::transform(arg.begin(), arg.end(), arg.begin(), [](unsigned char c){return std::tolower(c);});
        if(arg.compare("$backlight_intensity")){
            std::cout << "genConfig: [ FAILED ] Invalid modifier keyword: \"" << userArg << "\"" << std::endl;
            return 1;
        }
        if(verbose) std::cout << "genConfig: Found hold time config parameter: " << param << std::endl;
        if(param.length() == 1 && param[0] == '0') backlightIntensity = 0;
        if(param.length() > 3){
            std::cout << "genConfig: [ FAILED ] Backlight intensity must be set in range [0, 255], entered: " << param << std::endl;
            return 1;
        }
        for(int i = 0; i < param.length(); i++){
            if(!isdigit(param[i])){
                std::cout << "genConfig: [ FAILED ] Backlight intensity cannot cast to int -> found string: \'" << param << "\'" << std::endl;
                return 1;
            }
        }
        int backlightIntensityTemp = std::stoi(param);
        if(backlightIntensityTemp < 0 || backlightIntensityTemp > 255){
            std::cout << "genConfig: [ FAILED ] Backlight intensity must be set in range [0, 255], entered: " << param << std::endl;
            return 1;
        } else backlightIntensity = backlightIntensityTemp;
    }
    return 0;
}


/*  Return values:
    -2: empty line found (ignore)
    -1: comment line found (ignore)
    0: success (ignore)
    1: generic error (check)
*/
int parseLine(std::string line){
    if(line[0] == '#') return -1;       // comment is -1
    if(line.length() < 2) return -2;    // empty line is -2 
    std::string header;
    if(line.length() > 6){
        header = line.substr(0, 5);
        std::transform(header.begin(), header.end(), header.begin(), [](unsigned char c){return std::tolower(c);});
    }
    std::string bank = "";
    if(header == "[bank"){
        switch(std::tolower(line[5])){
            case '0': bank = "void bank0(uint8_t keyPressed, uint8_t OS){"; finalBank = bank; break;
            case '1': bank = "void bank1(uint8_t keyPressed, uint8_t OS){"; finalBank = bank; break;
            case '2': bank = "void bank2(uint8_t keyPressed, uint8_t OS){"; finalBank = bank; break;
            case '3': bank = "void bank3(uint8_t keyPressed, uint8_t OS){"; finalBank = bank; break;
            case '4': bank = "void bank4(uint8_t keyPressed, uint8_t OS){"; finalBank = bank; break;
            case '5': bank = "void bank5(uint8_t keyPressed, uint8_t OS){"; finalBank = bank; break;
            case '6': bank = "void bank6(uint8_t keyPressed, uint8_t OS){"; finalBank = bank; break;
            case '7': bank = "void bank7(uint8_t keyPressed, uint8_t OS){"; finalBank = bank; break;
            case '8': bank = "void bank8(uint8_t keyPressed, uint8_t OS){"; finalBank = bank; break;
            case '9': bank = "void bank9(uint8_t keyPressed, uint8_t OS){"; finalBank = bank; break;
            case 'a': bank = "void bankA(uint8_t keyPressed, uint8_t OS){"; finalBank = bank; break;
            case 'b': bank = "void bankB(uint8_t keyPressed, uint8_t OS){"; finalBank = bank; break;
            case 'c': bank = "void bankC(uint8_t keyPressed, uint8_t OS){"; finalBank = bank; break;
            case 'd': bank = "void bankD(uint8_t keyPressed, uint8_t OS){"; finalBank = bank; break;
            case 'e': bank = "void bankE(uint8_t keyPressed, uint8_t OS){"; finalBank = bank; break;
            case 'f': bank = "void bankF(uint8_t keyPressed, uint8_t OS){"; finalBank = bank; break;
            case 'g': bank = "void bankG(uint8_t keyPressed, uint8_t OS){"; finalBank = bank; break;
        }
        if(verbose) std::cout << "\ngenConfig: Bank header transforms to: " << bank << std::endl;
    }
    std::string tokenHeader;
    if(line.length() > 5 && line[0] != '#' && line[0] != '['){
        tokenHeader = line.substr(2, 3);
        std::transform(tokenHeader.begin(), tokenHeader.end(), tokenHeader.begin(), [](unsigned char c){return std::tolower(c);});
        if(verbose){
            if(tokenHeader == "com") std::cout << "genConfig: Found Combo assignment to: ";
            if(tokenHeader == "key") std::cout << "genConfig: Found Key assignment to: ";
            if(tokenHeader == "uni") std::cout << "genConfig: Found Unicode assignment to: ";
            if(tokenHeader == "str") std::cout << "genConfig: Found String assignment to: ";
        }
    }
    if((tokenHeader == "key" || tokenHeader == "com" || tokenHeader == "str" || tokenHeader == "uni") && line[1] == '_'){
        switch(std::tolower(line[0])){
            case '0': assignmentIndex = 0; break;
            case '1': assignmentIndex = 1; break;
            case '2': assignmentIndex = 2; break;
            case '3': assignmentIndex = 3; break;
            case '4': assignmentIndex = 4; break;
            case '5': assignmentIndex = 5; break;
            case '6': assignmentIndex = 6; break;
            case '7': assignmentIndex = 7; break;
            case '8': assignmentIndex = 8; break;
            case '9': assignmentIndex = 9; break;
            case 'a': assignmentIndex = 10; break;
            case 'b': assignmentIndex = 11; break;
            case 'c': assignmentIndex = 12; break;
            case 'd': assignmentIndex = 13; break;
            case 'e': assignmentIndex = 14; break;
            case 'f': assignmentIndex = 15; break;
        }
        int parseLineConfigRet = parseLineConfig(line, tokenHeader);
        if(parseLineConfigRet != 0) return 1;
        if(assignmentCount == 16){
            generateBankConfig(finalBank);
            if(verbose){
                for(int i = 0; i < 16; i++){
                    std::cout << "genConfig: Exported line for Linux:\t"<< linesLinux[i] << std::endl;
                    std::cout << "genConfig: Exported line for Windows:\t"<< linesWindows[i] << std::endl;
                    std::cout << "genConfig: Exported line for Mac:\t"<< linesMac[i] << std::endl;
                }
            }
            assignmentIndex = 0;
            assignmentCount = 0;
            clearStringArray();
        }
    }
    int checkVarRet = 0;
    if(!header.compare("$os_i")) checkVarRet = checkVar(0, line);    // assign init operating system
    if(!header.compare("$bank")) checkVarRet = checkVar(1, line);    // assign init bank       
    if(!header.compare("$debo")) checkVarRet = checkVar(2, line);    // assign debounce time
    if(!header.compare("$hold")) checkVarRet = checkVar(3, line);    // assign hold time
    if(!header.compare("$back")) checkVarRet = checkVar(4, line);    // assign idle backlight intensity
    if(checkVarRet) return 1;
    return 0;
}

int main(int argc, char **argv){
    if(argc > 1 && (!strcmp(argv[1], "-v") || !strcmp(argv[1], "--verbose"))){
        verbose = true;
        std::cout << "genConfig: Running in verbose mode" << std::endl;
    }
    if(argc > 1 && (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help"))){
        printHelp();
        return 0;
    }
    clearStringArray();
    bool parseLineError = false;
    std::string line = "";
    std::string outLine = "";
    std::ifstream config("banks.layout");
    std::ifstream file("config.h");
    if(file.good()) remove("config.h");
    file.close();
    while(!config.eof()){
        std::getline(config, line);
        int parseLineRet = parseLine(line);
        if(parseLineRet == 1){
            parseLineError = true;
            try{
                remove("config.h");
            }
            catch(std::exception &e){
                std::cout << "genConfig: Failed to remove \"config.h\": file doesn't exist" << std::endl;
            }
        }
    }
    includeBindingsHeader = true;
    config.close();
    if(parseLineError){
        std::cout << "genConfig: [ FAILED ] Could not parse line: Aborting..." << std::endl;
        return 1;
    }
    else return 0;
}